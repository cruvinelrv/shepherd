import '../../../../config/data/datasources/local/config_database.dart';
import '../../../../domains/data/datasources/local/domains_database.dart';
import '../../../../sync/domain/usecases/export_yaml_usecase.dart';
import 'init_domain_prompt.dart';
import 'init_owner_prompt.dart';
import 'init_repo_type_prompt.dart';
import 'init_github_prompt.dart';
import 'init_summary.dart';
import 'init_cancel_exception.dart';
import 'init_project_prompt.dart';
import 'init_microfrontends.dart';
import 'package:yaml/yaml.dart';
import 'dart:io';
import 'package:yaml_writer/yaml_writer.dart';

Future<void> showInitMenu() async {
  // [TEMPORARILY HIDDEN IN v0.3.0]
  // stdout.write('Do you want to clone and set up the Shepherd Dashboard web interface? (y/N): ');
  // final respDashboard = stdin.readLineSync()?.trim().toLowerCase();
  // if (respDashboard == 'y' || respDashboard == 'yes') {
  //   await cloneDashboard();
  // }
  // Always creates or overwrites feature_toggles.yaml with [] if it is empty or does not exist
  final featureTogglesFile = File('.shepherd/feature_toggles.yaml');
  if (!await featureTogglesFile.exists() ||
      (await featureTogglesFile.length() == 0)) {
    await featureTogglesFile.create(recursive: true);
    await featureTogglesFile.writeAsString('[]\n');
    print('feature_toggles.yaml created in .shepherd/.');
  }
  // Always generate sync_config.yaml with all files required by default
  final syncConfigFile = File('.shepherd/sync_config.yaml');
  final syncConfigContent =
      '''# Shepherd Sync Config\n# This file is auto-generated by shepherd init. All files are required by default.\n\nfiles:\n  - path: .shepherd/domains.yaml\n    required: true\n  - path: .shepherd/feature_toggles.yaml\n    required: true\n  - path: .shepherd/config.yaml\n    required: true\n  - path: .shepherd/environments.yaml\n    required: true\n  - path: .shepherd/project.yaml\n    required: true\n''';
  await syncConfigFile.writeAsString(syncConfigContent);
  print('sync_config.yaml generated in .shepherd/');
  // Root directory check
  final shepherdDir = Directory('${Directory.current.path}/.shepherd');
  final devopsDir = Directory('${Directory.current.path}/devops');
  if (!shepherdDir.existsSync() || !devopsDir.existsSync()) {
    print(
        '\x1B[31mShepherd must be run from the project root (where the .shepherd and devops folders exist).\x1B[0m');
    print('Current directory: \'${Directory.current.path}\'');
    return;
  }

  // Only shows the warning if project.yaml contains valid id and name
  final projectFile = File('.shepherd/project.yaml');
  final domainsFile = File('.shepherd/domains.yaml');
  bool projectYamlHasInfo = false;
  if (projectFile.existsSync()) {
    final content = await projectFile.readAsString();
    final loaded = content.trim().isEmpty ? null : loadYaml(content);
    if (loaded is Map && loaded['id'] != null && loaded['name'] != null) {
      projectYamlHasInfo = true;
    }
  }
  if (projectYamlHasInfo && domainsFile.existsSync()) {
    print(
        '\x1B[33mWarning: a Shepherd project is already initialized in this directory.\x1B[0m');
    print(
        'Continuing may overwrite configuration and the .shepherd/domains.yaml file.');
    stdout.write('Do you want to continue anyway? (y/N): ');
    final resp = stdin.readLineSync()?.trim().toLowerCase();
    if (resp != 'y' && resp != 'yes') {
      print('Operation cancelled.');
      return;
    }
  }
  print('\n================ SHEPHERD INIT ================\n');
  print('You can type 9 at any prompt to return to the main menu.');

  // Ask about microfrontends
  await promptInitMicrofrontends();

  final db = DomainsDatabase(Directory.current.path);
  final configDb = ConfigDatabase(Directory.current.path);

  try {
    // 0. Project registration
    final shepherdDir = Directory('${Directory.current.path}/.shepherd');
    if (!await shepherdDir.exists()) {
      await shepherdDir.create(recursive: true);
    }
    final projectFile = File('.shepherd/project.yaml');
    Map<String, String>? projectInfo;
    if (await projectFile.exists()) {
      // If project.yaml exists, load and show info, else prompt
      final content = await projectFile.readAsString();
      final loaded = content.trim().isEmpty ? null : loadYaml(content);
      if (loaded is Map && loaded['id'] != null && loaded['name'] != null) {
        print(
            'Project already registered: ${loaded['name']} (id: ${loaded['id']})');
        projectInfo = {
          'id': loaded['id'].toString(),
          'name': loaded['name'].toString()
        };
      } else {
        print('project.yaml file is empty or invalid. It will be overwritten.');
        projectInfo = await promptProjectInfo(allowCancel: true);
        if (projectInfo != null) {
          final yamlContent =
              'id: ${projectInfo['id']}\nname: ${projectInfo['name']}\n';
          try {
            await projectFile.writeAsString(yamlContent);
            print(
                'Project registered: ${projectInfo['name']} (id: ${projectInfo['id']})');
            print('Project file overwritten at: ${projectFile.path}');
          } catch (e) {
            print(
                '\x1B[31mError overwriting project.yaml at ${projectFile.path}: $e\x1B[0m');
          }
        }
      }
    } else {
      projectInfo = await promptProjectInfo(allowCancel: true);
      if (projectInfo != null) {
        final yamlContent =
            'id: ${projectInfo['id']}\nname: ${projectInfo['name']}\n';
        try {
          await projectFile.writeAsString(yamlContent);
          print(
              'Project registered: ${projectInfo['name']} (id: ${projectInfo['id']})');
          print('Project file saved at: ${projectFile.path}');
        } catch (e) {
          print(
              '\x1B[31mError saving project.yaml at ${projectFile.path}: $e\x1B[0m');
        }
      }
    }
    if (projectInfo == null) throw ShepherdInitCancelled();

    // 1. Environment registration
    final envFile = File('.shepherd/environments.yaml');
    Map<String, String> environments = {};
    if (envFile.existsSync()) {
      try {
        final content = envFile.readAsStringSync();
        final map = loadYaml(content);
        if (map is Map) {
          environments = Map<String, String>.from(map);
        }
      } catch (_) {
        environments = {};
      }
    }
    print('\nCurrent environments:');
    if (environments.isEmpty) {
      print('  (none)');
    } else {
      environments.forEach((env, branch) {
        print('  $env: $branch');
      });
    }
    while (true) {
      stdout.write('Add a new environment (leave blank to finish): ');
      final env = stdin.readLineSync()?.trim();
      if (env == null || env.isEmpty) break;
      if (!environments.containsKey(env)) {
        stdout.write('Enter the branch for "$env": ');
        final branch = stdin.readLineSync()?.trim();
        if (branch != null && branch.isNotEmpty) {
          environments[env] = branch;
          print('Environment "$env" with branch "$branch" added.');
        } else {
          print('Invalid branch.');
        }
      } else {
        print('Environment already exists.');
      }
    }
    final writer = YamlWriter();
    await envFile.writeAsString(writer.write(environments));
    print('Environments saved:');
    if (environments.isEmpty) {
      print('  (none)');
    } else {
      environments.forEach((env, branch) {
        print('  $env: $branch');
      });
    }

    // 2. Domain registration
    final domainName = await promptDomainName(allowCancel: true);
    if (domainName == null) throw ShepherdInitCancelled();

    // 3. Create domain immediately (with no owners yet)
    final existingDomains = await db.getAllDomainHealths();
    final alreadyExists =
        existingDomains.any((d) => d.domainName == domainName);
    if (!alreadyExists) {
      await db.insertDomain(
        domainName: domainName,
        score: 0.0,
        commits: 0,
        days: 0,
        warnings: '',
        personIds: [],
        projectPath: Directory.current.path,
      );
      print('Domain "$domainName" registered in database.');
    }

    // 4. Owner registration
    print('--- Owner registration ---');
    await promptOwners(db, domainName, allowCancel: true);

    // 5. Repository type selection and save
    final repoType = await promptRepoTypeAndSave(allowCancel: true);
    if (repoType == null) throw ShepherdInitCancelled();

    // 6. If GitHub, ensure owners have github_username
    if (repoType == 'github') {
      await ensureGithubUsernames(db, configDb, allowCancel: true);
    }

    // 7. Final summary
    await printInitSummary(db, domainName, repoType);

    // 8. Export domains.yaml automatically
    try {
      final exportYaml = await exportDomainsYaml(db);
      if (exportYaml) {
        print('domains.yaml file exported to .shepherd');
      } else {
        print('Could not export domains.yaml to .shepherd/.');
      }
    } catch (e) {
      print('Error exporting domains.yaml to .shepherd/:\n  31m$e 0m');
    }
  } on ShepherdInitCancelled {
    print('Init cancelled. Returning to main menu.');
    return;
  }
}

// Auxiliary function to export domains.yaml to .shepherd/
Future<bool> exportDomainsYaml(DomainsDatabase db) async {
  try {
    final useCase = ExportYamlUseCase(db);
    await useCase.exportYaml();
    return true;
  } catch (_) {
    return false;
  }
}
